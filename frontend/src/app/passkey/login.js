import { startAuthentication } from '@simplewebauthn/browser';
import { generateAuthenticationOptions, verifyAuthenticationResponse } from '@simplewebauthn/server';
import * as helpers from '@simplewebauthn/server/helpers';
//import * as deps from '@simplewebauthn/server/script/deps';


//0x067981c7f9f55bcbdd4e0d0a9c5bbcea77dacb42cccbf13554a847d6353f728e
//"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE0G8G_0m_ZgiZkfMdP8dedwA4LAwuMtu65tcWvXAW-oZWOZ1UUOCXTpbsleLmZUbRBwKfzuX-ozWTn87ng_Yvkg"
//"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEKnjhhDhAFP2ftHv8C3bEI8iPubw+JI6Xgflv3nIBA4QMBBmAkhwuI2M+w30NRb23OvqTIfuHkypKEXa3tdrASw=="
export async function loginCredentials() {
    const expectedOrigin = ['http://localhost:3000'];
    const rpId = 'localhost'

    const newChallenge = getNewChallenge()
    const challenge = convertChallenge(newChallenge)
    const buffer_challenge = base64ToArrayBuffer(challenge)
    console.log(challenge)


    /*
    const pubKeyCredentials = {
        challenge: buffer_challenge, // The challenge should be generated by the server
        rpId: rpId,
        allowCredentials: [
            
        ], // List of allowed credentials, can be empty to let the user choose
        userVerification: 'preferred',
        assertion: 'direct',
    };
    */


    const options = await generateAuthenticationOptions({
        rpID: rpId,
        challenge: buffer_challenge,
        userVerification: "preferred",
    })
    const credentials = await startAuthentication(options)
    //console.log("Credentials: ", credentials)

    const rawPubKey = "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE0G8G_0m_ZgiZkfMdP8dedwA4LAwuMtu65tcWvXAW-oZWOZ1UUOCXTpbsleLmZUbRBwKfzuX-ozWTn87ng_Yvkg"
    const pubKeyArray = helpers.isoBase64URL.toBuffer(rawPubKey, "base64url")
    const extraData = new Uint8Array([165, 1, 2, 3, 38, 32, 1, 33, 88, 32,])
    const extraData2 = new Uint8Array([34, 88, 32])
    const credPubKey_X = pubKeyArray.subarray(27, 59)
    const credPubKey_Y = pubKeyArray.subarray(59, pubKeyArray.length)
    //console.log(credPubKey_Y)
    const totalLength = extraData.length + extraData2.length + credPubKey_X.length + credPubKey_Y.length;

    // Create a new Uint8Array with the total length
    const combinedArray = new Uint8Array(totalLength);

    // Use the set method to concatenate the arrays
    let offset = 0;
    combinedArray.set(extraData, offset);
    offset += extraData.length;

    combinedArray.set(credPubKey_X, offset);
    offset += credPubKey_X.length;

    combinedArray.set(extraData2, offset);
    offset += extraData2.length;

    combinedArray.set(credPubKey_Y, offset);

    const clientDataBuffer = helpers.isoBase64URL.toBuffer(credentials.response.clientDataJSON, "base64url")
    const clientDataHashBuffer = await crypto.subtle.digest('SHA-256', clientDataBuffer)
    //console.log(clientDataHash)
    const clientDataHash = new Uint8Array(clientDataHashBuffer)
    //console.log(clientDataHash)
    const authDataBuffer = helpers.isoBase64URL.toBuffer(credentials.response.authenticatorData, "base64url")
    const signatureBuffer = helpers.isoBase64URL.toBuffer(credentials.response.signature, "base64url")
    const signature = convertEcdsaAsn1Signature(signatureBuffer);

    const signedData = helpers.isoUint8Array.concat([authDataBuffer, clientDataHash])
    //console.log(signedData)
    const uncompressedIndicator = new Uint8Array([0x04])
    const testPub = helpers.isoUint8Array.concat([credPubKey_X, credPubKey_Y])
    console.log(testPub)

    const publicKeyJwk = {
        kty: "EC",
        crv: "P-256",
        x: helpers.isoBase64URL.fromBuffer(credPubKey_X, "base64url"),
        y: helpers.isoBase64URL.fromBuffer(credPubKey_Y, "base64url"),
        ext: true
    };

    const publicKey = await crypto.subtle.importKey(
        'jwk', // The format of the key being imported
        publicKeyJwk,   // The key data in JWK format
        {
            name: 'ECDSA',
            namedCurve: 'P-256' // Ensure this matches the 'crv' in the JWK
        },
        true,   // Whether the key is extractable (e.g., can be exported)
        ['verify'] // The intended key usages
    );
    console.log(publicKey)

    const isValid = await crypto.subtle.verify(
        {
            name: 'ECDSA',
            hash: { name: 'SHA-256' }, // WebAuthn uses SHA-256
        },
        publicKey, // Public key
        signature, // Signature (ArrayBuffer or Uint8Array)
        signedData // Data that was signed (ArrayBuffer or Uint8Array)
    );
    console.log("Sig verification: ", isValid)



    /*
    const authenticatorData = { credentialPublicKey: combinedArray, }

    const response = await verifyAuthenticationResponse({
        response: credentials,
        expectedChallenge: challenge,
        expectedOrigin: expectedOrigin,
        authenticator: authenticatorData,
        expectedRPID: rpId,
    })
    console.log(response)
    */

    // Decode the attestationObject to extract the public key
    //const attestation = CBOR.decode(attestationObject);
    //const authData = attestation.authData;
};

const decodeBase64 = (encoded) => {
    return new Uint8Array(atob(encoded)
        .split('')
        .map((c) => c.charCodeAt(0)));
};

const decode = (input) => {
    try {
        return decodeBase64(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, ''));
    }
    catch (_a) {
        throw new TypeError('The input to be decoded is not correctly encoded.');
    }
};

function getNewChallenge() {
    return Math.random().toString(36).substring(2);
}
function convertChallenge(challenge) {
    return btoa(challenge).replaceAll('=', '');
}
function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

function toNormalizedBytes(bytes, componentLength) {
    let normalizedBytes;
    if (bytes.length < componentLength) {
        // In case the bytes are shorter than expected, we need to pad it with leading `0`s.
        normalizedBytes = new Uint8Array(componentLength);
        normalizedBytes.set(bytes, componentLength - bytes.length);
    }
    else if (bytes.length === componentLength) {
        normalizedBytes = bytes;
    }
    else if (bytes.length === componentLength + 1 && bytes[0] === 0 && (bytes[1] & 0x80) === 0x80) {
        // The bytes contain a leading `0` to encode that the integer is positive. This leading `0`
        // needs to be removed for compatibility with the SubtleCrypto Web Crypto API.
        normalizedBytes = bytes.subarray(1);
    }
    else {
        throw new Error(`Invalid signature component length ${bytes.length}, expected ${componentLength}`);
    }
    return normalizedBytes;
}

function decodeAsn1Signature(asn1Array) {
    // ASN.1 signatures are in the format: 0x30 | length | 0x02 | rLength | r | 0x02 | sLength | s
    // We're manually parsing this to extract `r` and `s`.

    //const asn1Array = new Uint8Array(asn1Signature);
    if (asn1Array[0] !== 0x30) {
        throw new Error("Invalid ASN.1 format");
    }

    let cursor = 2; // Start after 0x30 and length

    if (asn1Array[cursor] !== 0x02) {
        throw new Error("Invalid ASN.1 format for r");
    }

    const rLength = asn1Array[cursor + 1];
    const r = asn1Array.slice(cursor + 2, cursor + 2 + rLength);
    cursor += 2 + rLength;

    if (asn1Array[cursor] !== 0x02) {
        throw new Error("Invalid ASN.1 format for s");
    }

    const sLength = asn1Array[cursor + 1];
    const s = asn1Array.slice(cursor + 2, cursor + 2 + sLength);

    // Ensure r and s are of equal length (32 bytes each for P-256)
    const rPadded = new Uint8Array(32);
    const sPadded = new Uint8Array(32);
    rPadded.set(r, 32 - r.length);
    sPadded.set(s, 32 - s.length);

    // Concatenate r and s to form the final signature
    const concatenatedSignature = new Uint8Array(64);
    concatenatedSignature.set(rPadded, 0);
    concatenatedSignature.set(sPadded, 32);

    return concatenatedSignature;
}

function readAsn1IntegerSequence(input) {
    if (input[0] !== 0x30) throw new Error('Input is not an ASN.1 sequence');
    const seqLength = input[1];
    const elements = [];


    let current = input.slice(2, 2 + seqLength);
    while (current.length > 0) {
        const tag = current[0];
        if (tag !== 0x02) throw new Error('Expected ASN.1 sequence element to be an INTEGER');


        const elLength = current[1];
        elements.push(current.slice(2, 2 + elLength));


        current = current.slice(2 + elLength);
    }
    return elements;
}

function convertEcdsaAsn1Signature(input) {
    const elements = readAsn1IntegerSequence(input);
    if (elements.length !== 2) throw new Error('Expected 2 ASN.1 sequence elements');
    let [r, s] = elements;


    // R and S length is assumed multiple of 128bit.
    // If leading is 0 and modulo of length is 1 byte then
    // leading 0 is for two's complement and will be removed.
    if (r[0] === 0 && r.byteLength % 16 == 1) {
        r = r.slice(1);
    }
    if (s[0] === 0 && s.byteLength % 16 == 1) {
        s = s.slice(1);
    }


    // R and S length is assumed multiple of 128bit.
    // If missing a byte then it will be padded by 0.
    if ((r.byteLength % 16) == 15) {
        r = new Uint8Array(mergeBuffer(new Uint8Array([0]), r));
    }
    if ((s.byteLength % 16) == 15) {
        s = new Uint8Array(mergeBuffer(new Uint8Array([0]), s));
    }


    // If R and S length is not still multiple of 128bit,
    // then error
    if (r.byteLength % 16 != 0) throw Error("unknown ECDSA sig r length error");
    if (s.byteLength % 16 != 0) throw Error("unknown ECDSA sig s length error");


    return mergeBuffer(r, s);
}

function mergeBuffer(buffer1, buffer2) {
    const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
    return tmp.buffer;
}